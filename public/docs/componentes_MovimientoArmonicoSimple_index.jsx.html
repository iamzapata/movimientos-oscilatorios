

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      Documentación - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  
  <link type="text/css" rel="stylesheet" href="styles/collapse.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      Movimientos Ondulatorios
    </h3>

    
      <h3>
        Recursos
      </h3>
      
        <a href="https://fisica.app/" target="_blank">
        aplicación 
        | 
        </a> 
      
        <a href="https://github.com/iamzapata/movimientos-oscilatorios" target="_blank">
        repositorio 
         
        </a> 
      
    

    <h3>Modules</h3><ul><li id="MovimientoArmonicoSimple-nav"><a href="module-MovimientoArmonicoSimple.html">MovimientoArmonicoSimple</a></li><li id="MovimientoSobreAmortiguado-nav"><a href="module-MovimientoSobreAmortiguado.html">MovimientoSobreAmortiguado</a></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#ControlesAnimacion">ControlesAnimacion</a></li><li><a href="global.html#PI">PI</a></li><li><a href="global.html#PI2">PI2</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        Documentación
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>/**
 * @module {as} MovimientoArmonicoSimple
 */

import React, { Component } from "react";
import Head from "next/head";
import TextoAyuda from "componentes/MovimientoArmonicoSimple/TextoAyuda";
import Formulas from "componentes/MovimientoArmonicoSimple/Formulas";
import ValoresCalculados from "componentes/MovimientoArmonicoSimple/ValoresCalculados";
import ControlesVariables from "componentes/MovimientoArmonicoSimple/ControlesVariables";
import VelocidadAnimacion from "componentes/VelocidadAnimacion";
import ControlesAnimacion from "componentes/ControlesSimulacion";

import { PI, PI2 } from "constantes";

/**
 *  Este es un valor abritrario para simular
 *  que una oscilación con omega en 6.28 dura un segundo.
 *
 * @type {constante}
 */
const VALOR_INCREMEMENTO = 0.035;

/**
 * Amplitud mínima de oscilación.
 *
 * @type {constante}
 */
const AMPLITUD_MINIMA = -600;

/**
 * Amplitud máxima de oscilación.
 *
 * @type {constante}
 */
const AMPLITUD_MAXIMA = 600;

/**
 * Este es el estado inicial que describe la simulación
 * en el instante t = 0.
 *
 * @type {estado}
 */
const estadoInicial = {
  t: 0,
  dimensionBloque: 100,
  velocidadAnimacion: 1,
  amplitud: 0,
  masa: 1,
  K: 1,
  faseInicial: 0,
  faseInicialInput: 0,
  unidadesFaseInicial: "grados",
  reproduccionEnCurso: false,
  incremento: VALOR_INCREMEMENTO,

  frecuencia: 0,
  periodo: 0,
  posicion: 0,
  velocidad: 0,
  aceleracion: 0,
  fuerza: 0,
  frecuenciaAngular: 1,
  energiaCinetica: 0,
  energiaCineticaMax: 0,
  energiaPotencial: 0,
  energiaPotencialMax: 0,
  energiaMecanica: 0,
};

class MovimientoArmonicoSimple extends Component {
  state = {
    ...estadoInicial,
  };

  componentDidMount() {
    this.canvasPrincipal = document.getElementById("canvasprincipal");
    this.contextPrincipal = this.canvasPrincipal.getContext("2d");

    this.canvasSecundario = document.getElementById("canvassecundario");
    this.contextSecundario = this.canvasSecundario.getContext("2d");

    this.canvasFaseInicial = document.getElementById("canvasfaseinicial");
    this.contextFaseInicial = this.canvasFaseInicial.getContext("2d");

    this.canvasVectores = document.getElementById("canvasvectores");
    this.contextVectores = this.canvasVectores.getContext("2d");

    this.establecerResolucionCanvas(this.canvasPrincipal);
    this.establecerResolucionCanvas(this.canvasSecundario);
    this.establecerResolucionCanvas(this.canvasVectores);

    this.dibujarCanvas();
  }

  establecerResolucionCanvas = (canvas) => {
    const dpr = window.devicePixelRatio;

    canvas.width = 1000 * dpr;
    canvas.height = 400 * dpr;

    const { width, height } = canvas;

    this.width = width;
    this.height = height;

    canvas.style.width = `${width / dpr}px`;
    canvas.style.height = `${height / dpr}px`;
  };

  controlarSimulacion = (evento) => {
    const { velocidadAnimacion, faseInicialInput } = this.state;
    let { name, value } = evento.currentTarget;

    const valor = parseFloat(value);

    switch (name) {
      case "amplitud_range":
        this.actualizarAmplitudRange(valor);
        break;
      case "amplitud_input":
        this.actualizarAmplitudInput(valor ? valor : 0);
        break;
      case "frecuencia_angular":
        if (valor &lt; 0) {
          this.setState({ frecuenciaAngular: 0 });
          return;
        }
        this.setState({ frecuenciaAngular: valor ? valor : 0 });
        break;
      case "masa":
        if (valor &lt; 0) {
          this.setState({ masa: 0 });
          return;
        }
        this.setState({ masa: value }, () => this.actualizarFrecuenciaAngular());
        break;
      case "K":
        if (valor &lt; 0) {
          this.setState({ K: 0 });
          return;
        }
        this.setState({ K: value }, () => this.actualizarFrecuenciaAngular());
        break;
      case "fase_inicial":
        this.actualizarFaseInicial(valor);
        break;
      case "unidades_fase_inicial":
        this.setState({ unidadesFaseInicial: evento.target.value }, () => this.actualizarFaseInicial(faseInicialInput));
        break;
      case "iniciar":
        this.setState({ reproduccionEnCurso: true });
        break;
      case "pausar":
        this.setState({ reproduccionEnCurso: false });
        break;
      case "parar":
        this.reestablecerValores();
        this.limpiarAmplitudes();
        break;
      case "velocidad_animacion":
        this.actualizarVelocidadAnimacion(valor);
        break;
      case "mas_rapido":
        this.actualizarVelocidadAnimacion(Number(velocidadAnimacion) + 0.25);
        break;
      case "mas_lento":
        this.actualizarVelocidadAnimacion(Number(velocidadAnimacion) - 0.25);
        break;
      default:
        null;
    }
  };

  deshabilitarParar = () => {
    const { reproduccionEnCurso, amplitud } = this.state;

    return amplitud === 0 || !reproduccionEnCurso;
  };
  deshabilitarPausar = () => {
    const { reproduccionEnCurso, amplitud } = this.state;

    return amplitud === 0 || !reproduccionEnCurso;
  };
  deshabilitarIniciar = () => {
    const { amplitud } = this.state;
    return amplitud === 0;
  };
  reestablecerValores = () => {
    this.setState({
      ...estadoInicial,
    });
  };

  calcularPosicionEnCanvas = () => {
    const { width: anchoCanvas } = this;
    const { t, amplitud, frecuenciaAngular, faseInicial, dimensionBloque } = this.state;

    return amplitud * Math.cos(frecuenciaAngular * t + faseInicial) + anchoCanvas / 2 - dimensionBloque / 2;
  };

  calcularPosicionReal = () => {
    const { t, frecuenciaAngular, faseInicial, amplitud } = this.state;

    return amplitud * Math.cos(frecuenciaAngular * t + faseInicial);
  };

  calcularVelocidad = () => {
    const { t, frecuenciaAngular, faseInicial, amplitud } = this.state;

    return -amplitud * frecuenciaAngular * Math.sin(frecuenciaAngular * t + faseInicial);
  };

  calcularAceleracion = () => {
    const { frecuenciaAngular, amplitud, t, faseInicial } = this.state;

    return -amplitud * Math.pow(frecuenciaAngular, 2) * Math.cos(frecuenciaAngular * t + faseInicial);
  };

  calcularFuerza = () => {
    const { K } = this.state;
    return -K * this.calcularPosicionReal();
  };

  actualizarValoresCalculados = () => {
    const { frecuenciaAngular, amplitud, masa, K } = this.state;

    const frecuencia = frecuenciaAngular / PI2;
    const periodo = 1 / frecuencia;

    const posicion = this.calcularPosicionReal();
    const velocidad = this.calcularVelocidad();
    const aceleracion = this.calcularAceleracion();
    const fuerza = this.calcularFuerza();

    const energiaCinetica = 0.5 * masa * Math.pow(velocidad, 2);
    const energiaCineticaMax = 0.5 * masa * Math.pow(frecuenciaAngular, 2) * Math.pow(amplitud, 2);

    const energiaPotencial = 0.5 * K * Math.pow(posicion, 2);
    const energiaPotencialMax = 0.5 * K * Math.pow(amplitud, 2);

    const energiaMecanica = energiaCinetica + energiaPotencial;

    this.setState({
      frecuencia,
      periodo,
      posicion,
      velocidad,
      aceleracion,
      fuerza,
      energiaCinetica,
      energiaCineticaMax,
      energiaPotencial,
      energiaPotencialMax,
      energiaMecanica,
    });
  };

  actualizarVelocidadAnimacion = (valor) => {
    if (valor &lt; 0.25 || valor > 2.25) {
      return;
    }
    this.setState({ velocidadAnimacion: valor, incremento: VALOR_INCREMEMENTO * valor });
  };

  actualizarAmplitudInput = (valor) => {
    if (valor > AMPLITUD_MAXIMA || valor &lt; AMPLITUD_MINIMA) {
      const valorLimite = AMPLITUD_MAXIMA * Math.sign(valor);

      this.setState({ amplitud: valorLimite });
      this.limpiarAmplitudes();

      return;
    }

    this.limpiarAmplitudes();
    this.setState({ amplitud: valor });
  };

  actualizarAmplitudRange = (valor) => {
    if (valor > AMPLITUD_MAXIMA || valor &lt; AMPLITUD_MINIMA) {
      const valorLimite = AMPLITUD_MAXIMA * Math.sign(valor);
      inputAmplitud.value = valorLimite;
      this.setState({ amplitud: valorLimite });
      this.limpiarAmplitudes();
      return;
    }

    this.setState({ amplitud: valor });
    this.limpiarAmplitudes();
  };

  obtenerValorFaseInicial = (unidadesFaseInicial) => {
    const { faseInicial } = this.state;

    let valorFaseInicial = faseInicial;

    if (unidadesFaseInicial === "grados") {
      valorFaseInicial = faseInicial * (180 / PI);
    }

    return valorFaseInicial;
  };

  actualizarFaseInicial = (valor) => {
    const { unidadesFaseInicial } = this.state;

    if (!valor) return;

    if (unidadesFaseInicial === "grados") {
      this.setState({ faseInicial: valor * (PI / 180), faseInicialInput: valor });
      return;
    }

    if (unidadesFaseInicial === "radianes") {
      this.setState({ faseInicial: valor, faseInicialInput: valor });
      return;
    }
  };

  actualizarFrecuenciaAngular = () => {
    const { masa, K } = this.state;
    const frecuenciaAngular = Math.sqrt(K / masa);
    this.setState({ frecuenciaAngular });
  };

  dibujarResorte = () => {
    const { height: altoCanvas } = this;

    let xInicial = 1;
    let yInicial = altoCanvas / 2 - 50; // 50 es la mitdad el ancho del bloque
    let posicionXActual = this.state.x;
    const picos = 20;
    const altoPicos = 20;
    const relleno = 10;
    const colorDeAtras = "rgba(0, 0, 0, 0.9)";
    const colorDelFrente = "gray";
    const especorLinea = 10;

    const pasos = 1 / picos;

    const { contextPrincipal } = this;

    contextPrincipal.strokeStyle = colorDeAtras;
    contextPrincipal.lineWidth = especorLinea;
    contextPrincipal.lineJoin = "bevel";
    contextPrincipal.lineCap = "square";
    contextPrincipal.beginPath();
    contextPrincipal.moveTo(xInicial, yInicial);

    xInicial += relleno;
    posicionXActual -= relleno;
    let x = posicionXActual - xInicial;
    let finalCaminoY = 0;

    for (let i = 0; i &lt;= 1 - pasos; i += pasos) {
      for (let j = 0; j &lt; 1; j += pasos) {
        let xx = xInicial + x * (i + j * pasos);
        let yy = yInicial;
        xx -= Math.sin(j * PI2);
        yy += Math.sin(j * PI2) * altoPicos;
        contextPrincipal.lineTo(xx, yy);
      }
    }

    contextPrincipal.lineTo(posicionXActual, yInicial);
    contextPrincipal.lineTo(posicionXActual + relleno, yInicial);
    contextPrincipal.stroke();

    contextPrincipal.strokeStyle = colorDelFrente;
    contextPrincipal.lineWidth = especorLinea - 5;
    contextPrincipal.lineJoin = "round";
    contextPrincipal.lineCap = "round";
    contextPrincipal.beginPath();

    contextPrincipal.moveTo(xInicial - relleno, yInicial);
    contextPrincipal.lineTo(xInicial, yInicial);

    contextPrincipal.moveTo(posicionXActual, yInicial);
    contextPrincipal.lineTo(posicionXActual + relleno, yInicial);

    for (let i = 0; i &lt;= 1 - pasos; i += pasos) {
      for (let j = 0.25; j &lt;= 0.76; j += 0.01) {
        let xx = xInicial + x * (i + j * pasos);
        let yy = yInicial + finalCaminoY * (i + j * pasos);
        xx -= Math.sin(j * PI2);
        yy += Math.sin(j * PI2) * altoPicos;
        if (j === 0.25) {
          contextPrincipal.moveTo(xx, yy);
        } else {
          contextPrincipal.lineTo(xx, yy);
        }
      }
    }
    contextPrincipal.stroke();
  };

  dibujarMasa = () => {
    const yInitial = 0;
    const { x, dimensionBloque } = this.state;
    const { height: altoCanvas, contextPrincipal } = this;
    const y = yInitial + altoCanvas / 2 - dimensionBloque;

    contextPrincipal.save();
    contextPrincipal.fillStyle = "rgba(255, 0, 0, 1)";
    contextPrincipal.lineWidth = 1;
    contextPrincipal.fillStyle = "rgba(0, 0, 0, 0.3)";
    contextPrincipal.strokeRect(x, y, dimensionBloque, dimensionBloque);
    contextPrincipal.fillRect(x, y, dimensionBloque, dimensionBloque);
    contextPrincipal.restore();
  };

  dibujarPiso = (contextPrincipal, altoCanvas, anchoCanvas) => {
    contextPrincipal.save();
    contextPrincipal.beginPath();
    contextPrincipal.strokeStyle = "black";
    contextPrincipal.moveTo(0, altoCanvas / 2);
    contextPrincipal.lineTo(anchoCanvas, altoCanvas / 2);
    contextPrincipal.stroke();
    contextPrincipal.closePath();
    contextPrincipal.restore();
  };

  dibujarPared = (contextPrincipal, altoCanvas) => {
    contextPrincipal.save();
    contextPrincipal.lineWidth = 5;
    contextPrincipal.strokeStyle = "black";
    contextPrincipal.beginPath();
    contextPrincipal.moveTo(0, 0);
    contextPrincipal.lineTo(0, altoCanvas / 2);
    contextPrincipal.stroke();
    contextPrincipal.closePath();
    contextPrincipal.restore();
  };

  dibujarPuntoEquilibrio = () => {
    const { width: anchoCanvas, height: altoCanvas, contextSecundario: context } = this;

    context.save();
    context.lineWidth = 1;
    context.strokeStyle = "rgba(0, 0, 0, 0.5)";

    context.beginPath();
    context.setLineDash([10, 10]);
    context.moveTo(anchoCanvas / 2, 100);
    context.lineTo(anchoCanvas / 2, altoCanvas - 150);
    context.stroke();
    context.restore();
  };

  dibujarAnguloFaseInicial = () => {
    const { faseInicial } = this.state;
    const { canvasFaseInicial: canvas, contextFaseInicial: context } = this;
    const dpr = window.devicePixelRatio;
    const dimension = 70;

    canvas.width = dimension * dpr;
    canvas.height = dimension * dpr;

    const { width, height } = canvas;

    const centro = width / 2;

    canvas.style.width = `${width / dpr}px`;
    canvas.style.height = `${height / dpr}px`;

    const contrarioAlReloj = Math.sign(faseInicial) === 1;

    // Circunferencia
    context.save();
    context.beginPath();
    context.strokeStyle = "#7a7a7a";
    context.arc(centro, centro, 50, 0, PI2);
    context.stroke();
    context.restore();

    context.save();
    context.beginPath();
    context.fillStyle = `rgba(0, 255, 0, 0.5)`;
    context.moveTo(centro, centro);

    if (contrarioAlReloj) {
      context.arc(centro, centro, 50, 0, -faseInicial, true);
    } else {
      context.arc(centro, centro, 50, -faseInicial, 0, true);
    }

    context.lineTo(centro, centro);
    context.stroke();
    context.strokeStyle = "rgb(0, 255, 0)";
    context.fill();
    context.restore();
  };

  dibujarAmplitudes = () => {
    const { amplitud } = this.state;
    const { width: anchoCanvas, height: altoCanvas, contextSecundario: context } = this;

    if (amplitud === 0) return;

    const amplitudMasX = anchoCanvas / 2 + amplitud * Math.sign(amplitud);

    const amplitudMenosX = anchoCanvas / 2 - amplitud * Math.sign(amplitud);

    context.save();
    context.lineWidth = 0.5;
    context.strokeStyle = "rgba(0, 255, 0, 0.5)";

    context.beginPath();
    context.moveTo(amplitudMasX, 0);
    context.lineTo(amplitudMasX, altoCanvas - 100);
    context.stroke();
    context.closePath();

    context.beginPath();
    context.moveTo(amplitudMenosX, 0);
    context.lineTo(amplitudMenosX, altoCanvas - 100);
    context.stroke();
    context.closePath();

    context.restore();
  };

  dibujarVectorVelocidad = () => {
    const { amplitud, dimensionBloque } = this.state;
    const { width: anchoCanvas, contextVectores: context } = this;

    if (amplitud === 0) return;

    const posicionEnCanvas = this.calcularPosicionEnCanvas();

    const vectorVelocidad = this.calcularVelocidad();
    const posicionVectorVelocidadCola = posicionEnCanvas + dimensionBloque / 2;
    const posicionVectorVelocidadCabeza = posicionVectorVelocidadCola + vectorVelocidad;

    context.save();
    context.lineWidth = 4;
    context.strokeStyle = "red";
    context.beginPath();
    context.moveTo(posicionVectorVelocidadCola, 20);
    context.lineTo(posicionVectorVelocidadCabeza, 20);
    context.stroke();
    context.closePath();

    context.fillStyle = "red";
    context.font = "42px serif";
    context.fillText("v", anchoCanvas - 20, 30);

    context.beginPath();
    context.fillStyle = "red";
    context.moveTo(posicionVectorVelocidadCola + vectorVelocidad, 10);
    context.lineTo(posicionVectorVelocidadCola + vectorVelocidad, 30);
    context.lineTo(posicionVectorVelocidadCola + vectorVelocidad + Math.sign(vectorVelocidad) * 30, 20);
    context.fill();
    context.restore();
  };

  dibujarVectorAceleracion = () => {
    const { amplitud, dimensionBloque } = this.state;
    const { width: anchoCanvas, contextVectores: context } = this;

    if (amplitud === 0) return;

    const posicionEnCanvas = this.calcularPosicionEnCanvas();

    const posicionReal = this.calcularPosicionReal();
    const VectorAceleracion = this.calcularAceleracion(posicionReal);
    const posicionVectorAceleracionCola = posicionEnCanvas + dimensionBloque / 2;
    const posicionVectorAceleracionCabeza = posicionVectorAceleracionCola + VectorAceleracion;

    context.save();
    context.lineWidth = 4;
    context.strokeStyle = "blue";
    context.beginPath();
    context.moveTo(posicionVectorAceleracionCola, 60);
    context.lineTo(posicionVectorAceleracionCabeza, 60);
    context.stroke();
    context.closePath();

    context.fillStyle = "blue";
    context.font = "42px serif";
    context.fillText("a", anchoCanvas - 20, 60);

    context.beginPath();
    context.fillStyle = "blue";
    context.moveTo(posicionVectorAceleracionCola + VectorAceleracion, 50);
    context.lineTo(posicionVectorAceleracionCola + VectorAceleracion, 70);
    context.lineTo(posicionVectorAceleracionCola + VectorAceleracion + Math.sign(VectorAceleracion) * 30, 60);
    context.fill();
    context.restore();
  };

  dibujarVectorFuerza = () => {
    const { amplitud, dimensionBloque } = this.state;
    const { width: anchoCanvas, contextVectores: context } = this;

    if (amplitud === 0) return;

    const posicionEnCanvas = this.calcularPosicionEnCanvas();

    const posicionReal = this.calcularPosicionReal();
    const VectorFuerza = this.calcularFuerza(posicionReal);
    const posicionVectorFuerzaCola = posicionEnCanvas + dimensionBloque / 2;
    const posicionVectorFuerzaCabeza = posicionVectorFuerzaCola + VectorFuerza;

    context.save();
    context.lineWidth = 4;
    context.strokeStyle = "green";
    context.beginPath();
    context.moveTo(posicionVectorFuerzaCola, 100);
    context.lineTo(posicionVectorFuerzaCabeza, 100);
    context.stroke();
    context.closePath();

    context.fillStyle = "green";
    context.font = "42px serif";
    context.fillText("F", anchoCanvas - 25, 100);

    context.beginPath();
    context.fillStyle = "green";
    context.moveTo(posicionVectorFuerzaCola + VectorFuerza, 90);
    context.lineTo(posicionVectorFuerzaCola + VectorFuerza, 110);
    context.lineTo(posicionVectorFuerzaCola + VectorFuerza + Math.sign(VectorFuerza) * 30, 100);
    context.fill();
    context.restore();
  };

  dibujarVectores = () => {
    const { amplitud } = this.state;
    this.limpiarVectores();

    if (amplitud === 0) return;

    this.dibujarVectorVelocidad();
    this.dibujarVectorAceleracion();
    this.dibujarVectorFuerza();
  };

  dibujarCanvas = () => {
    const { width: anchoCanvas, height: altoCanvas, contextPrincipal } = this;
    const { t, reproduccionEnCurso, incremento } = this.state;

    const tiempoActual = t;

    this.dibujarPared(contextPrincipal, altoCanvas);
    this.dibujarPiso(contextPrincipal, altoCanvas, anchoCanvas);

    this.setState({ x: this.calcularPosicionEnCanvas() });

    this.limpiarTrayectoriaMasa();
    this.dibujarMasa();
    this.dibujarResorte();
    this.dibujarPuntoEquilibrio();
    this.dibujarAmplitudes();
    this.dibujarAnguloFaseInicial();
    this.dibujarVectores();
    this.actualizarValoresCalculados();

    contextPrincipal.restore();
    requestAnimationFrame(this.dibujarCanvas);

    if (reproduccionEnCurso) {
      this.setState({ t: t + incremento });
    } else {
      this.setState({ t: tiempoActual });
    }
  };

  limpiarAmplitudes = () => {
    const { width: anchoCanvas, height: altoCanvas, contextSecundario: context } = this;
    context.clearRect(0, 0, anchoCanvas, altoCanvas);
  };

  limpiarVectores = () => {
    const { width: anchoCanvas, height: altoCanvas, contextVectores: context } = this;
    context.clearRect(0, 0, anchoCanvas, altoCanvas);
  };

  limpiarTrayectoriaMasa = () => {
    const { dimensionBloque } = this.state;
    const { width: anchoCanvas, height: altoCanvas, contextPrincipal: context } = this;
    context.clearRect(5, altoCanvas / 2 - dimensionBloque - 10, anchoCanvas, dimensionBloque + 10);
  };

  render() {
    const { velocidadAnimacion } = this.state;
    const valorGrados = this.obtenerValorFaseInicial("grados").toFixed(0);
    const valorRadianes = this.obtenerValorFaseInicial("radianes").toFixed(2);

    return (
      &lt;>
        &lt;Head>
          &lt;title>M.A.S&lt;/title>
        &lt;/Head>

        &lt;div className="" style={{ width: "1000px" }}>
          &lt;h4 className="title is-4 text-center">Movimiento Armónico Simple&lt;/h4>

          &lt;div id="ventanagrafica">
            &lt;canvas id="canvassecundario">&lt;/canvas>
            &lt;canvas id="canvasprincipal">&lt;/canvas>
            &lt;canvas id="canvasvectores">&lt;/canvas>

            &lt;div className="columns">
              &lt;div className="column">
                &lt;VelocidadAnimacion
                  controlarSimulacion={this.controlarSimulacion}
                  velocidadAnimacion={velocidadAnimacion}
                />
              &lt;/div>
              &lt;div className="column">
                &lt;ControlesAnimacion
                  estado={this.state}
                  controlarSimulacion={this.controlarSimulacion}
                  deshabilitarParar={this.deshabilitarParar()}
                  deshabilitarPausar={this.deshabilitarPausar()}
                  deshabilitarIniciar={this.deshabilitarIniciar()}
                />
              &lt;/div>
            &lt;/div>
          &lt;/div>

          &lt;section className="section p-0">
            &lt;div className="container is-fluid is-paddingless">
              &lt;Formulas />

              &lt;TextoAyuda />

              &lt;ValoresCalculados estado={this.state} />

              &lt;ControlesVariables
                valorGrados={valorGrados}
                valorRadianes={valorRadianes}
                AMPLITUD_MAXIMA={AMPLITUD_MAXIMA}
                AMPLITUD_MINIMA={AMPLITUD_MINIMA}
                estado={this.state}
                controlarSimulacion={this.controlarSimulacion}
              />
            &lt;/div>
          &lt;/section>
        &lt;/div>
      &lt;/>
    );
  }
}

export default MovimientoArmonicoSimple;
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentación generada por <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
